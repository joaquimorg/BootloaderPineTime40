#ifndef PINETIME_BOARD_H
#define PINETIME_BOARD_H

#include "nrf_delay.h"
#include "nrf_gpio.h"
#include "display.h"

// Pinetime IO

#define LCD_LIGHT_1 NRF_GPIO_PIN_MAP(1, 4 )
//#define KEY_ACTION NRF_GPIO_PIN_MAP(1, 2 )

#define BUTTON_PULL    NRF_GPIO_PIN_PULLUP

// ------------------------------------------------------------------------------------------------------
/*
void button_init(uint32_t pin) {
  if (BUTTON_PULL == NRF_GPIO_PIN_PULLDOWN) {
    nrf_gpio_cfg_sense_input(pin, BUTTON_PULL, NRF_GPIO_PIN_SENSE_HIGH);
  }
  else {
    nrf_gpio_cfg_sense_input(pin, BUTTON_PULL, NRF_GPIO_PIN_SENSE_LOW);
  }
}

bool button_pressed(uint32_t pin) {
  uint32_t const active_state = (BUTTON_PULL == NRF_GPIO_PIN_PULLDOWN ? 1 : 0);
  return nrf_gpio_pin_read(pin) == active_state;
}
*/

// ------------------------------------------------------------------------------------------------------
// LCD

const uint8_t font_16_data[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0020 (space)
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,   // U+0021 (!)
    0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0022 (")
    0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00,   // U+0023 (#)
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,   // U+0024 ($) NEW /* U+007C (|) */
    0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00,   // U+0025 (%)
    0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00,   // U+0026 (&)
    0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,   // U+0027 (')
    0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00,   // U+0028 (()
    0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00,   // U+0029 ())
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,   // U+002A (*)
    0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00,   // U+002B (+)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // U+002C (,)
    0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,   // U+002D (-)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // U+002E (.)
    0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00,   // U+002F (/)
    0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00,   // U+0030 (0)
    0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00,   // U+0031 (1)
    0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00,   // U+0032 (2)
    0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00,   // U+0033 (3)
    0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00,   // U+0034 (4)
    0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00,   // U+0035 (5)
    0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00,   // U+0036 (6)
    0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00,   // U+0037 (7)
    0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00,   // U+0038 (8)
    0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00,   // U+0039 (9)
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00,   // U+003A (:)
    0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06,   // U+003B (//)
    0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00,   // U+003C (<)
    0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00,   // U+003D (=)
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00,   // U+003E (>)
    0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00,   // U+003F (?)
    0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00,   // U+0040 (@)
    0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00,   // U+0041 (A)
    0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00,   // U+0042 (B)
    0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00,   // U+0043 (C)
    0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00,   // U+0044 (D)
    0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00,   // U+0045 (E)
    0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00,   // U+0046 (F)
    0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00,   // U+0047 (G)
    0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00,   // U+0048 (H)
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+0049 (I)
    0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00,   // U+004A (J)
    0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00,   // U+004B (K)
    0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00,   // U+004C (L)
    0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00,   // U+004D (M)
    0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00,   // U+004E (N)
    0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00,   // U+004F (O)
    0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00,   // U+0050 (P)
    0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00,   // U+0051 (Q)
    0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00,   // U+0052 (R)
    0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00,   // U+0053 (S)
    0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00,   // U+0054 (T)
    0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00,   // U+0055 (U)
    0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00,   // U+0056 (V)
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,   // U+0057 (W)
    0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00,   // U+0058 (X)
    0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00,   // U+0059 (Y)
    0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00    // U+005A (Z)
};

#define RGB2COLOR(r, g, b) ((((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3)))

#define BCK_COLOR RGB2COLOR(0x00, 0x20, 0x00)

void display_fill(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {
  uint16_t i;

  uint8_t linebuffer[2 * 240];
  uint16_t bp = 0;

  set_addr_display(x1, y1, x2, y2);

  for (i = y1; i < y2; i++) {
    uint8_t rl = (x2 - x1);
    while (rl) {
      linebuffer[bp] = color >> 8;
      linebuffer[bp + 1] = color & 0xff;
      bp += 2;
      rl -= 1;

      if (bp >= sizeof(linebuffer)) {
        write_display(linebuffer, sizeof(linebuffer));
        bp = 0;
      }
    }
  }
}


#define GLYPH_SIZE 8

#define CHAR_ZOOM 2 

void lcd_pixel(uint16_t x1, uint16_t y1, uint16_t color) {
  uint8_t buffer[(CHAR_ZOOM * CHAR_ZOOM) * 2];
  uint8_t buffpos = 0;
  set_addr_display(x1, y1, CHAR_ZOOM, CHAR_ZOOM);
  for (uint8_t size = 0; size < CHAR_ZOOM * CHAR_ZOOM; size++) {
    buffer[buffpos++] = color >> 8;
    buffer[buffpos++] = color & 0xff;
  }
  write_display(buffer, sizeof(buffer));
}

void lcd_char(int x1, int y1, char ch, uint16_t color) {

  if (ch >= 'a') ch -= 'a' - 'A';
  int idx = ch - ' ';
  if (idx < 0 || idx >= sizeof(font_16_data)) return; // no char for this - just return

  for (int y = 0;y < GLYPH_SIZE;y++) {
    uint8_t pixel_data = font_16_data[(idx * GLYPH_SIZE) + y];
    for (int x = 0; x < 8; x++) {
      if ((pixel_data & (1 << x))) {
        lcd_pixel(x1 + (x * CHAR_ZOOM), y1 + y * CHAR_ZOOM, color);
      }/* else {
        lcd_pixel(x1 + (x * CHAR_ZOOM), y1 + y * CHAR_ZOOM, BCK_COLOR);
      }*/
    }

  }

}

void lcd_print(int x1, int y1, char* ch, uint16_t color) {

  display_fill(0, y1, 240, y1 + (GLYPH_SIZE * CHAR_ZOOM), BCK_COLOR);

  while (*ch) {
    lcd_char(x1, y1, *ch, color);
    x1 += 9 * CHAR_ZOOM;
    ch++;
  }
}

// ------------------------------------------------------------------------------------------------------
//
static void hardware_init(void) {

  // Backlight
  nrf_gpio_pin_clear(LCD_LIGHT_1);
  nrf_gpio_cfg_output(LCD_LIGHT_1);

  //button_init(KEY_ACTION);

  NRFX_DELAY_US(100); // wait for the pin state is stable

  init_display();

  display_fill(0, 0, 240, 240, BCK_COLOR);
  lcd_print(5, 10, "PINETIME 40", RGB2COLOR(255, 255, 255));
  lcd_print(5, 30, "BOOTLOADER", RGB2COLOR(200, 200, 200));
  lcd_print(5, 50, "V1.3", RGB2COLOR(200, 200, 200));


}

#endif // PINETIME_BOARD_H
